<script>
    /*
        연결리스트의 구현은 포인터를 사용하기 때문에 배열과 메모리차이가 존재
        찾을때는 배열을 
        추가와 삭제할 때는 연결리스트를 사용하는 것이 좋다. 
        상수시간만 소요됨 
    */
   //1. 단일 연결리스트 
   //2. 이중 연결리스트
   //3. circular 연결리스트

   class Node{
       constructor(value){
           this.value = value;
           this.next = null;
       }
   }
   class singlyLinkedList(){
        constructor(){
           this.head = null;
           this.tail = null;
        }

        find(value){
            let currNode = this.head; 
            while(currNode.value != value){
                currNode = currNode.next; 
            }
            //선형시간이 소요
            
            return currNode;
        }
        //추가 로직 - 1. 끝에 추가 append 
        append(newValue){
            const newNode = new Node(newValue); //새로운 노드 생성
            if( this.head === null ){ //연결리스트가 비어있기때문에 head와 tail에 넣어둠
                this.head = newNode;
                this.tail = newNode;
            }else{
                this.tail.next = newNode;
                this.tail = newNode;
            }
        }
        //추가로직 - 2. 중간에 추가 insert
        insert(node,newValue){
            const newNode = new Node(newValue);
            newNode.next = node.next;
            node.next = newNode;
        }
        //삭제 로직 - 입력값을 넣어서 찾기 : 선형시간 소요 
        remove(value){
            let prevNode = this.head;
            while(prevNode.next.value != value){
                prevNode = prevNode.next;
            }
            if(prevNode.next != null){
                prevNext = prevNode.next.next; //다음다음으로 연결되므로 해당 값은 아무것과 연결되지않음 (가비지콜랙션으로 나중에 제거됨)

            }
        } 
   }

</script>